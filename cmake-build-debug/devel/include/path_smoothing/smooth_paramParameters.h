// *********************************************************
//
// File autogenerated for the path_smoothing package
// by the rosparam_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <ros/param.h>
#include <ros/node_handle.h>
#include <rosparam_handler/utilities.hpp>
#ifdef DYNAMIC_RECONFIGURE_FOUND
#include <path_smoothing/smooth_paramConfig.h>
#else
struct smooth_paramConfig{};
#endif


namespace path_smoothing {

/// \brief Parameter struct generated by rosparam_handler
struct smooth_paramParameters {

  using Config = smooth_paramConfig;

  smooth_paramParameters(const ros::NodeHandle& private_node_handle)
  : globalNamespace{"/"},
    privateNamespace{private_node_handle.getNamespace() + "/"},
    nodeName{rosparam_handler::getNodeName(private_node_handle)} {}

  /// \brief Get values from parameter server
  /// 
  /// Will fail if a value can not be found and no default value is given.
  void fromParamServer(){
    bool success = true;
    success &= rosparam_handler::getParam(privateNamespace + "is_consider_boundary", is_consider_boundary, bool{true});
    success &= rosparam_handler::getParam(privateNamespace + "is_save_map", is_save_map, bool{false});
    success &= rosparam_handler::getParam(privateNamespace + "use_self_solver", use_self_solver, bool{false});
    success &= rosparam_handler::getParam(privateNamespace + "w1", w1, double{10.0});
    success &= rosparam_handler::getParam(privateNamespace + "w2", w2, double{5.0});
    success &= rosparam_handler::getParam(privateNamespace + "w3", w3, double{10.0});
    rosparam_handler::testMin<double>(privateNamespace + "w1", w1, 0);
    rosparam_handler::testMax<double>(privateNamespace + "w1", w1, 100);
    rosparam_handler::testMin<double>(privateNamespace + "w2", w2, 0);
    rosparam_handler::testMax<double>(privateNamespace + "w2", w2, 100);
    rosparam_handler::testMin<double>(privateNamespace + "w3", w3, 0);
    rosparam_handler::testMax<double>(privateNamespace + "w3", w3, 100);
    if(!success){
      missingParamsWarning();
      rosparam_handler::exit("RosparamHandler: GetParam could net retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
  }

  /// \brief Set parameters on ROS parameter server.
  void toParamServer(){
  rosparam_handler::setParam(privateNamespace + "is_consider_boundary",is_consider_boundary);
  rosparam_handler::setParam(privateNamespace + "is_save_map",is_save_map);
  rosparam_handler::setParam(privateNamespace + "use_self_solver",use_self_solver);
  rosparam_handler::setParam(privateNamespace + "w1",w1);
  rosparam_handler::setParam(privateNamespace + "w2",w2);
  rosparam_handler::setParam(privateNamespace + "w3",w3);        
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0){
#ifdef DYNAMIC_RECONFIGURE_FOUND
    is_consider_boundary = config.is_consider_boundary;
    is_save_map = config.is_save_map;
    use_self_solver = config.use_self_solver;
    w1 = config.w1;
    w2 = config.w2;
    w3 = config.w3;
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
  rosparam_handler::exit("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const smooth_paramParameters& p)
  {
    os << "[" << p.nodeName << "]\nNode " << p.nodeName << " has the following parameters:\n"
      << "	" << p.privateNamespace << "is_consider_boundary:" << p.is_consider_boundary << "\n"
      << "	" << p.privateNamespace << "is_save_map:" << p.is_save_map << "\n"
      << "	" << p.privateNamespace << "use_self_solver:" << p.use_self_solver << "\n"
      << "	" << p.privateNamespace << "w1:" << p.w1 << "\n"
      << "	" << p.privateNamespace << "w2:" << p.w2 << "\n"
      << "	" << p.privateNamespace << "w3:" << p.w3 << "\n"
;
    return os;
  }

    bool is_consider_boundary; /*!< if true, smoother will consider boundary or obstacle */
  bool is_save_map; /*!< if true, smoother will save distance map */
  bool use_self_solver; /*!< if false, smoother will use ceres to solve */
  double w1; /*!< weight for heading term */
  double w2; /*!< weight for curvature term */
  double w3; /*!< weight for obstacle term */

private:
  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << nodeName << "]\nThe following parameters do not have default values and need to be specified:\n"
    );
  }

  const std::string globalNamespace;
  const std::string privateNamespace;
  const std::string nodeName;
};

} // namespace path_smoothing
